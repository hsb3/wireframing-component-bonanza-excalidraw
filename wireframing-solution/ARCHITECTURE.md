# Wireframe Copilot Architecture

## Overview

This solution builds a custom React + LangGraph application for AI-driven wireframe generation. It takes inspiration from yctimlin/mcp_excalidraw but builds a standalone solution optimized for our component library.

## Why Custom Solution vs yctimlin Fork?

| Aspect | yctimlin Fork | Custom Solution (This) |
|--------|---------------|----------------------|
| **Component library** | No native support | Built-in, first-class |
| **Codebase control** | Fork maintenance burden | Clean, purpose-built |
| **Dependencies** | MCP protocol required | Direct LangGraph API |
| **Deployment** | Multi-service (Canvas + MCP) | Single service (all-in-one) |
| **Customization** | Limited by upstream changes | Full control |

## Architecture Layers

### Layer 1: Component Library (Already Built)
- 154 components × 3 themes = 462 unique components
- `.excalidrawlib` format
- Organized hierarchically (atoms → molecules → organisms → templates)
- Generated by `src/excalidraw_gen/`

### Layer 2: Component Registry (Auto-Generated)
- `component-registry.json` - Searchable metadata for all components
- Extracted dimensions, tags, categories, descriptions
- Enables AI to understand what components exist
- Script: `backend/scripts/generate_component_registry.py`

### Layer 3: LangGraph Deep Agent (Backend)
- Uses `create_deep_agent` for agentic tool use
- Tools: search_components, get_component, compose_wireframe, list_categories
- Claude Sonnet 4.5 for reasoning
- Exposes LangGraph API endpoints (`/threads`, `/runs`)
- FastAPI serves React static files

### Layer 4: React Frontend
- Embedded Excalidraw canvas
- Copilot chat panel
- Communicates via LangGraph SDK
- Streaming responses with `Client.runs.stream()`
- Single-page application

## Data Flow

```
User types description in chat
        ↓
Frontend: POST to /runs/stream (LangGraph API)
        ↓
Backend: LangGraph agent receives message
        ↓
Agent: Calls search_components tool
        ↓
Tool: Returns matching components from registry
        ↓
Agent: Plans layout, calls compose_wireframe tool
        ↓
Tool: Loads components from .excalidrawlib files
      Translates positions
      Generates .excalidraw JSON
      Saves to wireframes/
        ↓
Agent: Streams response back to frontend
        ↓
Frontend: Receives file path, loads JSON
        ↓
Frontend: Updates Excalidraw canvas via API
        ↓
User sees wireframe on canvas
```

## Key Design Decisions

### 1. Single-Origin Deployment
FastAPI serves both the LangGraph API and React static files from one server. No CORS issues, simpler deployment.

### 2. Composition vs Generation
Agent **composes** from pre-built components rather than **generating** raw Excalidraw JSON. This:
- Ensures consistent styling (theme system)
- Reduces token costs (LLM doesn't generate element JSON)
- Improves reliability (pre-validated components)
- Maintains design system integrity

### 3. File-Based Output
Wireframes saved as `.excalidraw` files on disk. User can:
- Edit in Excalidraw web app
- Share via file
- Version control
- Export to PNG/SVG

### 4. Theme-Aware
Agent understands 3 themes and selects appropriate components. User can request: "Create dashboard in abc123-dark theme"

## Component Registry Schema

```json
{
  "version": "1.0.0",
  "total_components": 1078,
  "themes": ["mork", "abc123-dark", "bronzer"],
  "categories": ["Frame", "Primitives", "Form", ...],
  "components": [
    {
      "id": "mork-42",
      "name": "B/Form/Input/Text",
      "theme": "mork",
      "category": "Form",
      "subcategory": "Input",
      "description": "Text input field",
      "dimensions": {"width": 250, "height": 65},
      "element_count": 3,
      "text_fields": ["Label", "Placeholder..."],
      "tags": ["form", "input", "text", "field"],
      "library_file": "output/mork-wireframe-kit.excalidrawlib",
      "library_index": 42
    }
  ]
}
```

## Workflow Examples

### Example 1: Login Screen
```
User: "Create a login screen"

Agent reasoning:
1. search_components("login") → Finds: SaaS: Login Form
2. Option A: Use pre-built login form component
3. compose_wireframe with single component

Agent reasoning:
1. search_components("email input") → B/Form/Input/Text
2. search_components("password input") → B/Form/Input/Text
3. search_components("button") → Button: Primary
4. Option B: Compose from individual components
5. compose_wireframe with 3 components at calculated positions

Response: "Login screen created at wireframes/login.excalidraw"
```

### Example 2: Complex Dashboard
```
User: "Dashboard with sidebar, header, 3 KPI metrics, and table"

Agent reasoning:
1. search_components("sidebar") → C/Shell/App/3Pane
2. search_components("header") → B/Nav/Header
3. search_components("metric") → SaaS: Metric Card (×3)
4. search_components("table") → SaaS: DataTable
5. Plans layout:
   - Sidebar at x=0 (240px wide)
   - Header at x=240, y=0 (rest of width)
   - Metrics at x=260, y=80, spaced 220px apart horizontally
   - Table at x=260, y=220
6. compose_wireframe with all components

Response: "Dashboard created with 6 components. File: wireframes/dashboard.excalidraw"
```

## Future Enhancements

### Phase 2: Enhanced Composition
- Automatic layout algorithms (flexbox-like)
- Component nesting (cards containing inputs)
- Responsive sizing based on canvas size

### Phase 3: Iterative Editing
- "Move sidebar to right" - Agent modifies existing wireframe
- "Replace table with chart" - Component substitution
- Multi-turn refinement

### Phase 4: Advanced Features
- Sketch-to-wireframe (upload hand-drawn, AI refines)
- Multi-page flows with navigation
- Export to PNG/PDF from UI
- Template library (save compositions as templates)
- Figma/Penpot export

## Comparison to Other Solutions

### vs MCP Server Only (Solution 2)
- **Pros:** Integrated UI, better visualization, no app switching
- **Cons:** More code to maintain, deployment complexity

### vs yctimlin Fork (Solution 1)
- **Pros:** Purpose-built for component library, cleaner codebase
- **Cons:** More initial setup (not starting from working canvas)

### Trade-offs
This solution optimizes for:
- Component library awareness (first-class)
- Development velocity (TypeScript + Python)
- User experience (integrated UI)
- Long-term maintainability (purpose-built)

At the cost of:
- Initial setup time (~2-3 days vs 1-2 hours for MCP-only)
- More code to maintain
- Deployment complexity (frontend + backend)

---

## Tech Stack

**Backend:**
- Python 3.11+
- LangGraph 0.4.4+ (deep agent framework)
- LangChain Anthropic (Claude API)
- FastAPI (HTTP server)

**Frontend:**
- React 19
- TypeScript
- Vite (build tool)
- Excalidraw embedded
- Tailwind CSS

**AI:**
- Claude Sonnet 4.5 (primary model)
- Streaming responses
- Tool use for composition

---

## Success Metrics

**MVP (Now):**
- ✅ User can describe screen → get wireframe
- ✅ Agent uses existing components (not generating from scratch)
- ✅ Wireframe appears on canvas
- ✅ Basic layouts work (login, dashboard, etc.)

**V1.0 (Next):**
- Agent handles complex multi-component screens
- Iterative refinement works ("add X", "move Y")
- Export to PNG directly from UI
- Template saving/loading

**V2.0 (Future):**
- Sketch-to-wireframe
- Multi-page flows
- Team collaboration
- Figma integration
